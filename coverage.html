
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>CSCE3550_jwks_server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/corigne/CSCE3550_jwks_server/handlers.go (88.1%)</option>
				
				<option value="file1">github.com/corigne/CSCE3550_jwks_server/main.go (0.0%)</option>
				
				<option value="file2">github.com/corigne/CSCE3550_jwks_server/middleware.go (94.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "crypto/rand"
        "crypto/rsa"
        "encoding/base64"
        "encoding/json"
        "log"
        "math/big"
        "net/http"
        "sync"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

type Key struct {
        PrivateKey *rsa.PrivateKey
        Kid        string
        ExpiresAt  time.Time
}

type JWKS struct {
        Keys []map[string]interface{} `json:"keys"`
}

var (
        keys     []Key
        keysLock sync.RWMutex
)

func registerHandlers() <span class="cov8" title="1">{
        mux.Handle("/", mid.Then(http.HandlerFunc(index)))
        mux.Handle("/.well-known/jwks.json", mid.Then(http.HandlerFunc(jwksHandler)))
        mux.Handle("/auth", mid.Then(http.HandlerFunc(authHandler)))
}</span>

func methodNotAllowedHandler(w http.ResponseWriter, _ *http.Request) <span class="cov8" title="1">{
        http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
}</span>

func index(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.URL.Path != "/" </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusNotFound)
                w.Write([]byte("404 page not found\n"))
                return
        }</span>
        <span class="cov8" title="1">if req.Method != http.MethodGet </span><span class="cov8" title="1">{
                methodNotAllowedHandler(w, req)
                return
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusOK)

        resp := make(map[string]string)
        resp["message"] = "welcome to the njj0057 JWKS Server - STATUS: OK"
        resp["start_time"] = startTime.Local().Format(time.RFC3339)
        resp["uptime"] = time.Since(startTime).String()

        jsonResp, err := json.Marshal(resp)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error in JSON Marshal. Err: %s", err)
        }</span>

        <span class="cov8" title="1">_, err = w.Write(jsonResp)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Unable to write to http response writer.")
        }</span>
}

func genKeys() <span class="cov8" title="1">{
        keysLock.Lock()
        defer keysLock.Unlock()

        var hasExpired, hasUnexpired bool
        for _, key := range keys </span><span class="cov8" title="1">{
                if key.ExpiresAt.Before(time.Now()) </span><span class="cov8" title="1">{
                        hasExpired = true
                }</span> else<span class="cov8" title="1"> {
                        hasUnexpired = true
                }</span>
        }

        <span class="cov8" title="1">if !hasExpired </span><span class="cov8" title="1">{
                privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to generate expired RSA key: %v", err)
                }</span>
                <span class="cov8" title="1">keys = append(keys, Key{
                        PrivateKey: privateKey,
                        Kid:        "expiredkey",
                        ExpiresAt:  time.Now().Add(-5 * time.Minute),
                })</span>
        }

        <span class="cov8" title="1">if !hasUnexpired </span><span class="cov8" title="1">{
                privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("Failed to generate unexpired RSA key: %v", err)
                }</span>
                <span class="cov8" title="1">keys = append(keys, Key{
                        PrivateKey: privateKey,
                        Kid:        "validkey",
                        ExpiresAt:  time.Now().Add(10 * time.Minute),
                })</span>
        }
}

func encodeBase64(b *big.Int) string <span class="cov8" title="1">{
        return base64.RawURLEncoding.EncodeToString(b.Bytes())
}</span>

func jwksHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Method != http.MethodGet </span><span class="cov8" title="1">{
                methodNotAllowedHandler(w, req)
                return
        }</span>

        <span class="cov8" title="1">keysLock.RLock()
        defer keysLock.RUnlock()

        jwks := JWKS{}
        for _, key := range keys </span><span class="cov8" title="1">{
                if key.ExpiresAt.After(time.Now()) </span><span class="cov8" title="1">{
                        pubKey := key.PrivateKey.Public().(*rsa.PublicKey)
                        jwks.Keys = append(jwks.Keys, map[string]interface{}{
                                "kty": "RSA",
                                "kid": key.Kid,
                                "exp": key.ExpiresAt.Unix(),
                                "alg": "RS256",
                                "n":   encodeBase64(pubKey.N),
                                "e":   "AQAB",
                        })
                }</span>
        }

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        err := json.NewEncoder(w).Encode(jwks)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Unable to encode jwks json.")
        }</span>
}

func authHandler(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if req.Method != http.MethodPost </span><span class="cov8" title="1">{
                methodNotAllowedHandler(w, req)
                return
        }</span>
        <span class="cov8" title="1">genKeys()
        expired := req.URL.Query().Get("expired") == "true"

        keysLock.RLock()
        var signingKey *Key
        for _, key := range keys </span><span class="cov8" title="1">{
                if expired </span><span class="cov8" title="1">{
                        if key.ExpiresAt.Before(time.Now()) </span><span class="cov8" title="1">{
                                signingKey = &amp;key
                                break</span>
                        }
                } else<span class="cov8" title="1"> {
                        if key.ExpiresAt.After(time.Now()) </span><span class="cov8" title="1">{
                                signingKey = &amp;key
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">keysLock.RUnlock()

        if signingKey == nil </span><span class="cov0" title="0">{
                http.Error(w, "No valid signing key available", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">token := jwt.NewWithClaims(jwt.SigningMethodRS256, jwt.MapClaims{
                "sub": "example_user",
                "iat": time.Now().Unix(),
                "exp": signingKey.ExpiresAt.Unix(),
        })
        token.Header["kid"] = signingKey.Kid

        signedToken, err := token.SignedString(signingKey.PrivateKey)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Failed to sign token", http.StatusInternalServerError)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        err = json.NewEncoder(w).Encode(map[string]string{"token": signedToken})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Unable to encode token json.")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "log"
        "net/http"
        "time"
)

var (
        startTime time.Time
        mux       *http.ServeMux = http.NewServeMux()
)

const HTTP_LISTEN_PORT = 8080

func main() <span class="cov0" title="0">{
        genKeys()
        registerHandlers()

        startTime = time.Now()
        fmt.Printf("Starting JWKS server at: %v...\n", startTime.Local().Format(time.RFC3339))
        err := http.ListenAndServe(fmt.Sprintf(":%d", HTTP_LISTEN_PORT), mux)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("ERROR IN HTTP SERVER: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "github.com/justinas/alice"
        "log"
        "mime"
        "net/http"
        "net/http/httputil"
)

var (
        mid alice.Chain = alice.New(enforceJSONHandler, responseLogger)
)

func enforceJSONHandler(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                contentType := r.Header.Get("Content-Type")

                if contentType != "" </span><span class="cov8" title="1">{
                        mt, _, err := mime.ParseMediaType(contentType)
                        if err != nil </span><span class="cov8" title="1">{
                                http.Error(w, "Malformed Content-Type header", http.StatusBadRequest)
                                return
                        }</span>

                        <span class="cov8" title="1">if mt != "application/json" </span><span class="cov8" title="1">{
                                http.Error(w, "Content-Type header must be application/json", http.StatusUnsupportedMediaType)
                                return
                        }</span>
                }

                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

func responseLogger(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) </span><span class="cov8" title="1">{
                reqDump, err := httputil.DumpRequest(req, true)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("ERROR: %v", err)
                }</span>
                <span class="cov8" title="1">log.Printf("REQ: %s", string(reqDump))
                next.ServeHTTP(w, req)</span>
        })
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
